<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Mobile 3D Hand Particle System</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: system-ui, sans-serif;
}
#canvas-container {
  position: fixed;
  inset: 0;
}
#video-input {
  position: fixed;
  bottom: 10px;
  right: 10px;
  width: 140px;
  height: 105px;
  border-radius: 10px;
  border: 2px solid cyan;
  opacity: 0.5;
  transform: scaleX(-1);
}
#ui {
  position: fixed;
  top: 10px;
  left: 10px;
  color: cyan;
  font-size: 14px;
  text-shadow: 0 0 6px black;
}
#loading {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: cyan;
  font-size: 20px;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>

<body>
<div id="loading">Loading Hand Trackingâ€¦</div>
<div id="ui">Shape: <span id="shape-name">Sphere</span></div>
<!-- Add autoplay/playsinline/muted so mobile browsers allow camera autoplay -->
<video id="video-input" autoplay muted playsinline></video>
<div id="canvas-container"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const isMobile = window.innerWidth < 768;
const particleCount = isMobile ? 5000 : 12000;

// Scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 30;

const renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
document.getElementById("canvas-container").appendChild(renderer.domElement);

// Particles
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const targets = new Float32Array(particleCount * 3);

for (let i = 0; i < positions.length; i++)
  positions[i] = (Math.random() - 0.5) * 50;

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({
  size: 0.4,
  color: 0x00ffff,
  transparent: true,
  opacity: 0.85,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

// Shapes
const shapes = ["Sphere", "Burst"];
let shapeIndex = 0;

function updateShape(name) {
  document.getElementById("shape-name").innerText = name;
  for (let i = 0; i < particleCount; i++) {
    if (name === "Sphere") {
      const phi = Math.acos(-1 + (2 * i) / particleCount);
      const theta = Math.sqrt(particleCount * Math.PI) * phi;
      targets[i*3] = 12 * Math.cos(theta) * Math.sin(phi);
      targets[i*3+1] = 12 * Math.sin(theta) * Math.sin(phi);
      targets[i*3+2] = 12 * Math.cos(phi);
    } else {
      targets[i*3] = (Math.random() - 0.5) * 40;
      targets[i*3+1] = (Math.random() - 0.5) * 40;
      targets[i*3+2] = (Math.random() - 0.5) * 40;
    }
  }
}
updateShape("Sphere");

// MediaPipe
let scale = 1;
let lastSwitch = 0;

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 0,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults(res => {
  document.getElementById("loading").style.display = "none";
  if (!res || !res.multiHandLandmarks || res.multiHandLandmarks.length === 0) return;

  const lm = res.multiHandLandmarks[0];

  // pinch distance between thumb tip (4) and index tip (8)
  const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
  // tune multiplier and clamp to a comfortable range
  scale = THREE.MathUtils.clamp(pinch * 6, 0.4, 2.5);

  // simple gesture: index finger above pip (8.y < 6.y) to switch shape
  if (lm[8].y < lm[6].y && Date.now() - lastSwitch > 1500) {
    shapeIndex = (shapeIndex + 1) % shapes.length;
    updateShape(shapes[shapeIndex]);
    lastSwitch = Date.now();
  }
});

// Get the video element and ensure attributes are set for mobile autoplay
const video = document.getElementById("video-input");
video.muted = true;
video.playsInline = true;
video.autoplay = true;

// Camera from MediaPipe utils: pass the video element reference
const cam = new Camera(video, {
  onFrame: async () => {
    // send the actual video element each frame
    await hands.send({ image: video });
  },
  width: 480,
  height: 360
});
cam.start();

// Also allow a tap/click to toggle shapes as a fallback
document.addEventListener('click', () => {
  shapeIndex = (shapeIndex + 1) % shapes.length;
  updateShape(shapes[shapeIndex]);
});

// Animate
function animate() {
  requestAnimationFrame(animate);
  const p = geometry.attributes.position.array;
  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3;
    p[i3] += (targets[i3] * scale - p[i3]) * 0.07;
    p[i3+1] += (targets[i3+1] * scale - p[i3+1]) * 0.07;
    p[i3+2] += (targets[i3+2] * scale - p[i3+2]) * 0.07;
  }
  geometry.attributes.position.needsUpdate = true;
  particles.rotation.y += 0.002;
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>